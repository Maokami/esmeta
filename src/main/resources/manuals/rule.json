{
  "[YET] Let _realmRec_ be a new Realm Record.": "let realmRec = @REALM",
  "[YET] Let _intrinsics_ be a new Record.": "let intrinsics = (new Record())",
  "[YET] Set fields of _intrinsics_ with the values listed in <emu-xref href=\"#table-well-known-intrinsic-objects\"></emu-xref>. The field names are the names listed in column one of the table. The value of each field is a new object value fully and recursively populated with property values as defined by the specification of each object in clauses <emu-xref href=\"#sec-global-object\"></emu-xref> through <emu-xref href=\"#sec-reflection\"></emu-xref>. All object property values are newly created object values. All values that are built-in function objects are created by performing CreateBuiltinFunction(_steps_, _length_, _name_, _slots_, _realmRec_, _prototype_) where _steps_ is the definition of that function provided by this specification, _name_ is the initial value of the function's `name` property, _length_ is the initial value of the function's `length` property, _slots_ is a list of the names, if any, of the function's specified internal slots, and _prototype_ is the specified value of the function's [[Prototype]] internal slot. The creation of the intrinsics and their properties must be ordered to avoid any dependencies upon objects that have not yet been created.": "{ intrinsics = @INTRINSICS realmRec.Intrinsics = @INTRINSICS }",
  "[YET] Assert: _realm_.[[Intrinsics]].[[%ThrowTypeError%]] exists and has been initialized.": "assert (! (= realm.Intrinsics.ThrowTypeError absent))",
  "[YET] If _O_ does not have an own property with key _P_, return *undefined*.": "if (= O.SubMap[P] absent) return undefined else {}",
  "[YET] Create an own accessor property named _P_ of object _O_ whose [[Get]], [[Set]], [[Enumerable]], and [[Configurable]] attributes are set to the value of the corresponding field in _Desc_ if _Desc_ has that field, or to the attribute's <emu-xref href=\"#table-object-property-attributes\">default value</emu-xref> otherwise.": "{ let ap = (new PropertyDescriptor()) if (= Desc.Get absent) ap.Get = undefined else ap.Get = Desc.Get if (= Desc.Set absent) ap.Set = undefined else ap.Set = Desc.Set if (= Desc.Enumerable absent) ap.Enumerable = false else ap.Enumerable = Desc.Enumerable if (= Desc.Configurable absent) ap.Configurable = false else ap.Configurable = Desc.Configurable O.SubMap[P] = ap }",
  "[YET] Create an own data property named _P_ of object _O_ whose [[Value]], [[Writable]], [[Enumerable]], and [[Configurable]] attributes are set to the value of the corresponding field in _Desc_ if _Desc_ has that field, or to the attribute's <emu-xref href=\"#table-object-property-attributes\">default value</emu-xref> otherwise.": "{ let dp = (new PropertyDescriptor()) if (= Desc.Value absent) dp.Value = undefined else dp.Value = Desc.Value if (= Desc.Writable absent) dp.Writable = false else dp.Writable = Desc.Writable if (= Desc.Enumerable absent) dp.Enumerable = false else dp.Enumerable = Desc.Enumerable if (= Desc.Configurable absent) dp.Configurable = false else dp.Configurable = Desc.Configurable O.SubMap[P] = dp }",
  "[YET] Let _newContext_ be a new execution context.": "let newContext = (new ExecutionContext())",
  "[YET] If the host requires use of an exotic object to serve as _realm_'s global object, let _global_ be such an object created in a host-defined manner. Otherwise, let _global_ be *undefined*, indicating that an ordinary object should be created as the global object.": "let global = undefined",
  "[YET] If the host requires that the `this` binding in _realm_'s global scope return an object other than the global object, let _thisValue_ be such an object created in a host-defined manner. Otherwise, let _thisValue_ be *undefined*, indicating that _realm_'s global `this` binding should be the global object.": "let thisValue = undefined",
  "[YET] If _additionalInternalSlotsList_ is present, append each of its elements to _internalSlotsList_.": "if (! (= additionalInternalSlotsList absent)) internalSlotsList = (list-concat internalSlotsList additionalInternalSlotsList) else {}",
  "[YET] Let _obj_ be a newly created object with an internal slot for each name in _internalSlotsList_.": "{ let obj = (new OrdinaryObject()) let idx = 0 loop[repeat] (< idx internalSlotsList.length) { obj[internalSlotsList[idx]] = undefined idx = (+ idx 1) } }",
  "[YET] Set _obj_'s essential internal methods to the default ordinary object definitions specified in <emu-xref href=\"#sec-ordinary-object-internal-methods-and-internal-slots\"></emu-xref>.": "nop",
  "[YET] Assert: If the caller will not be overriding both _obj_'s [[GetPrototypeOf]] and [[SetPrototypeOf]] essential internal methods, then _internalSlotsList_ contains [[Prototype]].": "assert true",
  "[YET] Assert: If the caller will not be overriding all of _obj_'s [[SetPrototypeOf]], [[IsExtensible]], and [[PreventExtensions]] essential internal methods, then _internalSlotsList_ contains [[Extensible]].": "assert true",
  "[YET] Let _env_ be a new object Environment Record.": "let env = (new ObjectEnvironmentRecord())",
  "[YET] Let _dclRec_ be a new declarative Environment Record containing no bindings.": "let dclRec = (new DeclarativeEnvironmentRecord())",
  "[YET] Let _env_ be a new global Environment Record.": "let env = (new GlobalEnvironmentRecord())",
  "[YET] For each property of the Global Object specified in clause <emu-xref href=\"#sec-global-object\"></emu-xref>, do\n  1. [YET] Let _name_ be the String value of the property name.\n  1. [YET] Let _desc_ be the fully populated data Property Descriptor for the property, containing the specified attributes for the property. For properties listed in <emu-xref href=\"#sec-function-properties-of-the-global-object\"></emu-xref>, <emu-xref href=\"#sec-constructor-properties-of-the-global-object\"></emu-xref>, or <emu-xref href=\"#sec-other-properties-of-the-global-object\"></emu-xref> the value of the [[Value]] attribute is the corresponding intrinsic object from _realmRec_.\n  1. Perform ? DefinePropertyOrThrow(_global_, _name_, _desc_).": "{ let keys = (keys @GLOBAL.SubMap) let idx = 0 loop[repeat] (< idx keys.length) { let name = keys[idx] global.SubMap[name] = @GLOBAL.SubMap[name] idx = (+ idx 1) } }",
  "[YET] Create any host-defined global object properties on _globalObj_.": "nop",
  "[YET] If the execution context stack is empty, return *null*.": "if (= @EXECUTION_STACK.length 0) return null else {}",
  "[YET] Let _ec_ be the topmost execution context on the execution context stack whose ScriptOrModule component is not *null*.": "{ let ec = absent let idx = @EXECUTION_STACK.length loop[repeat] (&& (< 0 idx) (= ec absent)) { idx = (- idx 1) if (! (= @EXECUTION_STACK[idx].ScriptOrModule null) ) ec = @EXECUTION_STACK[idx] else {}} }",
  "[YET] If no such execution context exists, return *null*. Otherwise, return _ec_'s ScriptOrModule.": "if (= ec absent) return null else return ec.ScriptOrModule",
  "[YET] If _script_ is a List of errors, return _script_.": "nop",
  "[YET] Let _scriptContext_ be a new ECMAScript code execution context.": "let scriptContext = (new ExecutionContext())",
  "[YET] If _envRec_ has a binding for the name that is the value of _N_, return *true*.": "if (! (= envRec.SubMap[N] absent)) return true else {}",
  "[YET] Assert: The execution context stack is not empty.": "assert (! (= @EXECUTION_STACK.length 0))",
  "[YET] Resume the context that is now on the top of the execution context stack as the running execution context.": "@CONTEXT = @EXECUTION_STACK[(- @EXECUTION_STACK.length 1)]",
  "[YET] Let _D_ be a newly created Property Descriptor with no fields.": "let D = (new PropertyDescriptor())",
  "[YET] Let _X_ be _O_'s own property whose key is _P_.": "let X = O.SubMap[P]",
  "[YET] Set _D_.[[Value]] to the value of _X_'s [[Value]] attribute.": "D.Value = X.Value",
  "[YET] Set _D_.[[Writable]] to the value of _X_'s [[Writable]] attribute.": "D.Writable = X.Writable",
  "[YET] Set _D_.[[Enumerable]] to the value of _X_'s [[Enumerable]] attribute.": "D.Enumerable = X.Enumerable",
  "[YET] Set _D_.[[Configurable]] to the value of _X_'s [[Configurable]] attribute.": "D.Configurable = X.Configurable",
  "[YET] If _Desc_ does not have any fields, return *true*.": "{ let descKeys = (keys Desc) if (= descKeys.length 0) return true else {} }",
  "[YET] If _x_ and _y_ are both *true* or both *false*, return *true*; otherwise, return *false*.": "if (|| (&& (= x true) (= y true)) (&& (= x false) (= y false))) return true else return false",
  "[YET] For each field of _Desc_, set the corresponding attribute of the property named _P_ of object _O_ to the value of the field.": "{ let fields = (keys Desc) let idx = 0 loop[repeat] (< idx fields.length) { let f = fields[idx] O.SubMap[P][f] = Desc[f] idx = (+ idx 1) } }",
  "[YET] Assert: _envRec_ does not already have a binding for _N_.": "assert (= envRec.SubMap[N] absent)",
  "[YET] Create a mutable binding in _envRec_ for _N_ and record that it is uninitialized. If _D_ is *true*, record that the newly created binding may be deleted by a subsequent DeleteBinding call.": "{ envRec.SubMap[N] = (new MutableBinding(\"initialized\" -> false))  if (= D true) envRec.SubMap[N].maybeDeleted = true else {} }",
  "[YET] Assert: _envRec_ has a binding for _N_.": "assert (! (= envRec.SubMap[N] absent))",
  "[YET] If the binding for _N_ in _envRec_ is an uninitialized binding, throw a *ReferenceError* exception.": "if (! envRec.SubMap[N].initialized) return comp[~throw~/~empty~]((new OrdinaryObject(\"Prototype\" -> @CONTEXT.Realm.Intrinsics.TypeError.SubMap.prototype.Value, \"ErrorData\" -> undefined))) else {}",
  "[YET] Return the value currently bound to _N_ in _envRec_.": "return envRec.SubMap[N].BoundValue",
  "[YET] Insert _d_ as the first element of _functionsToInitialize_.": "push d > functionsToInitialize",
  "[YET] If the source text matched by _Body_ is strict mode code, let _Strict_ be *true*; else let _Strict_ be *false*.": "if true let Strict = true else let Strict = false",
  "[YET] Assert: _F_ is an extensible object that does not have a *\"length\"* own property.": "assert (&& F.Extensible (= F.SubMap.length absent))",
  "[YET] Assert: _F_ is an extensible object that does not have a *\"name\"* own property.": "assert (&& F.Extensible (= F.SubMap.name absent))",
  "[YET] Assert: _F_ is an extensible object that does not have a *\"prototype\"* own property.": "assert (&& F.Extensible (= F.SubMap.prototype absent))",
  "[YET] Let _calleeContext_ be a new ECMAScript code execution context.": "let calleeContext = (new ExecutionContext())",
  "[YET] Let _env_ be a new function Environment Record containing no bindings.": "let env = (new FunctionEnvironmentRecord)",
  "[YET] If _callerContext_ is not already suspended, suspend _callerContext_.": "if false nop else {}",
  "[YET] Assert: _calleeContext_ is now the running execution context.": "assert (= calleeContext @EXECUTION_STACK[(- @EXECUTION_STACK.length 1)])",
  "[YET] Assert: _localEnv_ is a function Environment Record.": "assert (? localEnv: FunctionEnvironmentRecord)",
  "[YET] Assert: The next step never returns an abrupt completion because _localEnv_.[[ThisBindingStatus]] is not ~initialized~.": "assert true",
  "[YET] Let _instantiatedVarNames_ be a copy of the List _parameterBindings_.": "let instantiatedVarNames = (copy parameterBindings)",
  "[YET] Insert _fn_ as the first element of _functionNames_.": "push fn > functionNames",
  "[YET] If _parameterNames_ has any duplicate entries, let _hasDuplicates_ be *true*. Otherwise, let _hasDuplicates_ be *false*.": "call hasDuplicates = @IsDuplicate(parameterNames)",
  "[YET] Let _calleeContext_ be a new execution context.": "let calleeContext = (new ExecutionContext())",
  "[YET] Remove _calleeContext_ from the execution context stack and restore _callerContext_ as the running execution context.": "{ (pop > @EXECUTION_STACK) @CONTEXT = callerContext }",
  "[YET] Perform any necessary implementation-defined initialization of _calleeContext_.": "nop",
  "[YET] Let _result_ be the Completion Record that is the result of evaluating _F_ in a manner that conforms to the specification of _F_. _thisArgument_ is the *this* value, _argumentsList_ provides the named parameters, and the NewTarget value is *undefined*.": "call result = F.Code(thisArgument, argumentsList, undefined)",
  "[YET] Assert: _generatorBody_ is an Abstract Closure with no parameters.": "assert (? generatorBody: AbstractClosure)",
  "[YET] Assert: _genContext_ is the execution context of a generator.": "assert (? genContext: ExecutionContext)",
  "[YET] If _genContext_ does not have a Generator component, return ~non-generator~.": "if (= genContext.Generator absent) return ~non-generator~ else {}",
  "[YET] Remove _genContext_ from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.": "{ (pop > @EXECUTION_STACK) @CONTEXT = @EXECUTION_STACK[(- @EXECUTION_STACK.length 1)] }",
  "[YET] Assert: If we return here, the generator either threw an exception or performed either an implicit or explicit return.": "assert true",
  "[YET] Once a generator enters the ~completed~ state it never leaves it and its associated execution context is never resumed. Any execution state associated with _generator_ can be discarded at this point.": "nop"
}
