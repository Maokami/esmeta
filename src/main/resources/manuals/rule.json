{
  "[YET] Let _realmRec_ be a new Realm Record.": "let realmRec = (new RealmRecord())[#0]",
  "[YET] Let _intrinsics_ be a new Record.": "let intrinsics = @INTRINSICS",
  "[YET] Set fields of _intrinsics_ with the values listed in <emu-xref href=\"#table-well-known-intrinsic-objects\"></emu-xref>. The field names are the names listed in column one of the table. The value of each field is a new object value fully and recursively populated with property values as defined by the specification of each object in clauses <emu-xref href=\"#sec-global-object\"></emu-xref> through <emu-xref href=\"#sec-reflection\"></emu-xref>. All object property values are newly created object values. All values that are built-in function objects are created by performing CreateBuiltinFunction(_steps_, _length_, _name_, _slots_, _realmRec_, _prototype_) where _steps_ is the definition of that function provided by this specification, _name_ is the initial value of the function's `name` property, _length_ is the initial value of the function's `length` property, _slots_ is a list of the names, if any, of the function's specified internal slots, and _prototype_ is the specified value of the function's [[Prototype]] internal slot. The creation of the intrinsics and their properties must be ordered to avoid any dependencies upon objects that have not yet been created.": "intrinsics = @INTRINSICS",
  "[YET] Assert: _realm_.[[Intrinsics]].[[%ThrowTypeError%]] exists and has been initialized.": "assert (! (= realm.Intrinsics.ThrowTypeError absent))",
  "[YET] If _O_ does not have an own property with key _P_, return *undefined*.": "if (= O.SubMap[P] absent) then return undefined else {}",
  "[YET] Create an own accessor property named _P_ of object _O_ whose [[Get]], [[Set]], [[Enumerable]], and [[Configurable]] attributes are set to the value of the corresponding field in _Desc_ if _Desc_ has that field, or to the attribute's <emu-xref href=\"#table-object-property-attributes\">default value</emu-xref> otherwise.": "{ let ap = (new AccessorProperty())[#0] if (= Desc.Get absent) then ap.Get = undefined else ap.Get = Desc.Get if (= Desc.Set absent) then ap.Set = undefined else ap.Set = Desc.Set if (= Desc.Enumerable absent) then ap.Enumerable = false else ap.Enumerable = Desc.Enumerable if (= Desc.Configurable absent) then ap.Configurable = false else ap.Configurable = Desc.Configurable O.SubMap[P] = ap }",
  "[YET] Let _newContext_ be a new execution context.": "let newContext = (new ExecutionContext())[#0]",
  "[YET] If the host requires use of an exotic object to serve as _realm_'s global object, let _global_ be such an object created in a host-defined manner. Otherwise, let _global_ be *undefined*, indicating that an ordinary object should be created as the global object.": "let global = undefined",
  "[YET] If the host requires that the `this` binding in _realm_'s global scope return an object other than the global object, let _thisValue_ be such an object created in a host-defined manner. Otherwise, let _thisValue_ be *undefined*, indicating that _realm_'s global `this` binding should be the global object.": "let thisValue = undefined",
  "[YET] If _additionalInternalSlotsList_ is present, append each of its elements to _internalSlotsList_.": "if (! (= additionalInternalSlotsList absent)) then internalSlotsList = (list-concat internalSlotsList additionalInternalSlotsList)[#0] else {}",
  "[YET] Let _obj_ be a newly created object with an internal slot for each name in _internalSlotsList_.": "{ let obj = (new OrdinaryObject())[#0] let idx = 0 loop[repeat] (< idx internalSlotsList.length) then { obj[internalSlotsList[idx]] = undefined idx = (+ idx 1) } }",
  "[YET] Set _obj_'s essential internal methods to the default ordinary object definitions specified in <emu-xref href=\"#sec-ordinary-object-internal-methods-and-internal-slots\"></emu-xref>.": "nop",
  "[YET] Assert: If the caller will not be overriding both _obj_'s [[GetPrototypeOf]] and [[SetPrototypeOf]] essential internal methods, then _internalSlotsList_ contains [[Prototype]].": "assert true",
  "[YET] Assert: If the caller will not be overriding all of _obj_'s [[SetPrototypeOf]], [[IsExtensible]], and [[PreventExtensions]] essential internal methods, then _internalSlotsList_ contains [[Extensible]].": "assert true",
  "[YET] Let _env_ be a new object Environment Record.": "let env = (new ObjectEnvironmentRecord())[#0]",
  "[YET] Let _dclRec_ be a new declarative Environment Record containing no bindings.": "let dclRec = (new DeclarartiveEnvironmentRecord())[#0]",
  "[YET] Let _env_ be a new global Environment Record.": "let env = (new GlobalEnvironmentRecord())[#0]",
  "[YET] For each property of the Global Object specified in clause <emu-xref href=\"#sec-global-object\"></emu-xref>, do\n  1. [YET] Let _name_ be the String value of the property name.\n  1. [YET] Let _desc_ be the fully populated data Property Descriptor for the property, containing the specified attributes for the property. For properties listed in <emu-xref href=\"#sec-function-properties-of-the-global-object\"></emu-xref>, <emu-xref href=\"#sec-constructor-properties-of-the-global-object\"></emu-xref>, or <emu-xref href=\"#sec-other-properties-of-the-global-object\"></emu-xref> the value of the [[Value]] attribute is the corresponding intrinsic object from _realmRec_.\n  1. Perform ? DefinePropertyOrThrow(_global_, _name_, _desc_).": "{ let keys = (keys @GLOBAL_OBJECT.SubMap)[#0] let idx = 0 loop[repeat] (< idx keys.length) then { let name = keys[idx] global.SubMap[name] = @GLOBAL_OBJECT.SubMap[name] idx = (+ idx 1) } }",
  "[YET] Create any host-defined global object properties on _globalObj_.": "nop",
  "[YET] If the execution context stack is empty, return *null*.": "if (= @EXECUTION_STACK.length 0) then return null else {}",
  "[YET] Let _ec_ be the topmost execution context on the execution context stack whose ScriptOrModule component is not *null*.": "{ let ec = absent let idx = @EXECUTION_STACK.length loop[repeat] (&& (< 0 idx) (= ec absent)) then { idx = (- idx 1) if (! (= @EXECUTION_STACK[idx].ScriptOrModule null) ) then ec = @EXECUTION_STACK[idx] else {}} }",
  "[YET] If no such execution context exists, return *null*. Otherwise, return _ec_'s ScriptOrModule.": "if (= ec absent) then return null else return ec.ScriptOrModule",
  "[YET] If _script_ is a List of errors, return _script_.": "nop",
  "[YET] Let _scriptContext_ be a new ECMAScript code execution context.": "let scriptContext = (new ExecutionContext())[#0]"
}
